#!/usr/bin/env python

import argparse
import sys
import re

from lxml import etree

def fan(name):
    """Convert a name to a Fandango identifier."""
    return re.sub(r"[^a-zA-Z0-9_]", "_", name)


# See https://lxml.de/validation.html#dtd-1 for information on DTD structure

class DTDConverter(object):
    """Convert a DTD schema to a Fandango grammar."""
    def __init__(self, dtd, source="<DTD file>"):
        self.source = source
        self.dtd = dtd
        self.entities = {}
        for entity in dtd.iterentities():
            # print(f"name = {entity.name}, orig = {entity.orig}, content = {entity.content}")
            self.entities[entity.name] = entity.content

    def header(self):
        s = f"""
# This file contains a Fandango grammar for a DTD schema.
# Automatically generated by schema2fan from {self.source!r}. Do not edit.
#
<ws> ::= <whitespace>+ := ' '  # whitespace sequence
<q> ::= ('"' | "'")? := '"'    # optional quote
        """
        return s

    def convert(self) -> str:
        s = self.header()
        for element in self.dtd.iterelements():
            s += self.convert_element(element)
        return s

    def convert_element(self, element) -> str:
        s = f"\n\n# {element.name}\n"
        s += f"<{fan(element.name)}> ::= '<{element.name}' (<ws> <{fan(element.name)}_attribute>)* ('/>' | '>' "
        s += self.convert_content(element.content)
        s += f" '</{fan(element.name)}>')\n"
        s += self.convert_attributes(element)
        return s

    def convert_content(self, content):
        if content is None:
            return ""

        s = ""
        match content.type:
            case "pcdata":
                s += "<pcdata>"
            case "element":
                s += f"<{fan(content.name)}>"
            case "seq":
                s += (self.convert_content(content.left) + " "
                      + self.convert_content(content.right))
            case "or":
                s += (self.convert_content(content.left) + " | "
                      + self.convert_content(content.right))
            case _:
                raise ValueError(f"Unknown content type {content.type!r}")

        match content.occur:
            case "once":
                pass
            case "opt":
                s = f"({s})?"
            case "mult":
                s = f"({s})*"
            case "plus":
                s = f"({s})+"
            case _:
                raise ValueError(f"Unknown occurrence {content.occur!r}")

        return s

    def convert_attributes(self, element) -> str:
        s = f"<{fan(element.name)}_attribute> ::= "
        s += "\n    | ".join(self.convert_attribute(attribute) for attribute in element.iterattributes())
        return s

    def convert_attribute(self, attribute) -> str:
        s = f"'{fan(attribute.name)}='"
        match attribute.type:
            case "enumeration":
                values = " <ws> <q> (" + " | ".join(f"{value!r}" for value in attribute.itervalues()) + ") <q>"
                s += values
            case _:
                s += f" <{fan(attribute.type)}> "

        s += f"  # {attribute.default}, default = {repr(attribute.default_value)}"

        return s


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Convert a [DTD] schema to a Fandango specification"
    )

    parser.add_argument(
        "-i", "--id",
        dest="ids",
        action="append",
        type=str,
        help="schema ID (e.g. '-//W3C//DTD SVG 1.1//EN')"
    )
    parser.add_argument(
        dest="files",
        action="append",
        type=argparse.FileType('r'),
        help="schema file"
    )

    args = parser.parse_args(sys.argv[1:])

    for arg in (args.ids or []) + (args.files or []):
        if isinstance(arg, str):
            tree = etree.DTD(external_id=bytes(arg, 'ascii'))
            source = arg
        else:
            tree = etree.DTD(arg)
            source = arg.name

        converter = DTDConverter(tree, source)
        print(converter.convert())
