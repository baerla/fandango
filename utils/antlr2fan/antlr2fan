#!/usr/bin/env python

import sys

from antlr4 import *
from ANTLRv4Lexer import ANTLRv4Lexer
from ANTLRv4Parser import ANTLRv4Parser
from ANTLRv4ParserVisitor import ANTLRv4ParserVisitor
from typing import Any

def strip_quotes(s: str) -> str:
    """Strip quotes from a string."""
    if s.startswith('"') and s.endswith('"'):
        return s[1:-1]
    elif s.startswith("'") and s.endswith("'"):
        return s[1:-1]
    return s

def invert_range(range_str: str) -> str:
    """Invert a character range string."""
    if range_str.startswith('[') and range_str.endswith(']'):
        content = range_str[1:-1]
        if content.startswith('^'):
            content = content[1:]  # Remove the negation
        else:
            content = '^' + content  # Add negation
        return f"[{content}]"
    return "not " + range_str  # Cannot handle

def quote(s: str) -> str:
    """Quote a string if it is not already quoted."""
    if "'" in s and '"' in s:
        return f'"""{s}"""'
    if "'" in s:
        return f'"{s}"'
    return f"'{s}'"

def rquote(s: str) -> str:
    return 'r' + quote(s)

class ANTLR2FanVisitor(ANTLRv4ParserVisitor):
    def visitChildren(self, ctx: Any):
        # This method can be customized to handle children nodes
        if ctx is None or ctx.children is None:
            return ""

        children_s = []
        for child in ctx.children or []:
            s = self.visit(child)
            if s:
                children_s.append(s)
        return "".join(children_s)

    def visitGrammarDecl(self, ctx: ANTLRv4Parser.GrammarDeclContext):
        return '# ' + ctx.identifier().getText() + '\n'

    def visitParserRuleSpec(self, ctx: ANTLRv4Parser.ParserRuleSpecContext):
        # This method can be customized to handle rule specifications
        nonterminal = ctx.RULE_REF().getText()
        return f"<{nonterminal}> ::= " + self.visitChildren(ctx) + '\n'

    def visitRuleAltList(self, ctx: ANTLRv4Parser.RuleAltListContext):
        # This method can be customized to handle alternative lists
        children_s = []
        for child in ctx.children or []:
            s = self.visit(child)
            if s == "":
                s = "''"
            if s is not None:
                children_s.append(s)
        return " | ".join(children_s)

    def visitAltList(self, ctx: ANTLRv4Parser.AltListContext):
        # This method can be customized to handle alternative lists
        children_s = []
        for child in ctx.children or []:
            s = self.visit(child)
            if s == "":
                s = "''"
            if s is not None:
                children_s.append(s)
        return " | ".join(children_s)

    def visitAlternative(self, ctx: ANTLRv4Parser.AlternativeContext):
        # This method can be customized to handle alternatives
        children_s = []
        for child in ctx.children or []:
            s = self.visit(child)
            if s is not None:
                children_s.append(s)
        return " ".join(children_s)

    def visitLexerAltList(self, ctx: ANTLRv4Parser.LexerAltListContext):
        # This method can be customized to handle alternatives
        children_s = []
        for child in ctx.children or []:
            s = self.visit(child)
            if s is not None:
                children_s.append(s)
        return " | ".join(children_s)

    def visitEbnf(self, ctx: ANTLRv4Parser.EbnfContext):
        if ctx.blockSuffix():
            # Handle EBNF with block suffix
            return self.visit(ctx.block()) + self.visit(ctx.blockSuffix())
        return super().visitEbnf(ctx)

    def visitElement(self, ctx: ANTLRv4Parser.ElementContext):
        s = ""
        if ctx.labeledElement():
            # Handle labeled elements
            s = self.visit(ctx.labeledElement())
        if ctx.atom():
            # Handle atoms
            s = self.visit(ctx.atom())
        if ctx.ebnf():
            # Handle EBNF constructs
            s = self.visit(ctx.ebnf())
        if ctx.actionBlock():
            # Handle action blocks
            s = self.visit(ctx.actionBlock())
        if ctx.ebnfSuffix():
            # Handle EBNF suffixes
            s += self.visit(ctx.ebnfSuffix())
        return s

    def visitWildcard(self, ctx: ANTLRv4Parser.WildcardContext):
        return rquote('.')

    def visitEbnfSuffix(self, ctx: ANTLRv4Parser.EbnfSuffixContext):
        return ctx.getText() if ctx else ""

    def visitLexerRuleSpec(self, ctx: ANTLRv4Parser.LexerRuleSpecContext):
        # This method can be customized to handle rule specifications
        nonterminal = ctx.TOKEN_REF().getText()
        return f"<{nonterminal}> ::= " + self.visitChildren(ctx) + '\n'

    def visitRuleref(self, ctx: ANTLRv4Parser.RulerefContext):
        # Handle rule references
        rule_name = ctx.RULE_REF().getText()
        return f"<{rule_name}>"

    def visitTerminalDef(self, ctx: ANTLRv4Parser.TerminalDefContext):
        if ctx.STRING_LITERAL():
            terminal = ctx.STRING_LITERAL().getText()
            return f"{terminal}"
        elif ctx.TOKEN_REF():
            token = ctx.TOKEN_REF().getText()
            return f"<{token}>"
        elif ctx.LEXER_CHAR_SET():
            char_set = ctx.LEXER_CHAR_SET().getText()
            return f"{char_set}"
        else:
            elem = ctx.getText()
            return f"{elem}"

    def visitLexerElement(self, ctx: ANTLRv4Parser.LexerElementContext):
        s = ""
        if ctx.lexerAtom():
            s = self.visit(ctx.lexerAtom())
        if ctx.lexerBlock():
            s = self.visit(ctx.lexerBlock())
        if ctx.ebnfSuffix():
            s += self.visit(ctx.ebnfSuffix())
        return s

    def visitLexerElements(self, ctx: ANTLRv4Parser.LexerElementsContext):
        # This method can be customized to handle alternatives
        children_s = []
        for child in ctx.children or []:
            s = self.visit(child)
            if s is not None:
                children_s.append(s)
        return " ".join(children_s)

    def visitLexerBlock(self, ctx: ANTLRv4Parser.LexerBlockContext):
        return "(" + super().visitLexerBlock(ctx) + ")"

    def visitBlockSet(self, ctx: ANTLRv4Parser.BlockSetContext):
        return "(" + super().visitBlockSet(ctx) + ")"

    def visitBlock(self, ctx: ANTLRv4Parser.BlockSetContext):
        return "(" + super().visitBlock(ctx) + ")"

    def visitLexerAtom(self, ctx: ANTLRv4Parser.LexerAtomContext):
        if ctx.LEXER_CHAR_SET():
            # Handle lexer character sets
            return rquote(ctx.LEXER_CHAR_SET().getText())
        return super().visitLexerAtom(ctx)

    def visitCharacterRange(self, ctx: ANTLRv4Parser.CharacterRangeContext):
        range_start = strip_quotes(ctx.STRING_LITERAL(0).getText())
        range_end = strip_quotes(ctx.STRING_LITERAL(1).getText())
        return rquote(f'[{range_start}-{range_end}]')

    def visitNotSet(self, ctx: ANTLRv4Parser.NotSetContext):
        if ctx.setElement():
            # Handle not set elements
            return rquote(invert_range(ctx.setElement().getText()))
        if ctx.blockSet():
            # Handle not set elements
            return rquote(invert_range(ctx.blockSet().getText()))
        return super().visitChildren(ctx)

    def visitTerminal(self, node: TerminalNode):
        # Handle terminal nodes
        # print(f"Visiting terminal: {node.getText()}")
        return super().visitTerminal(node)

def process(filename):
    g4content = open(filename, 'r').read()
    input_stream = InputStream(g4content)

    lexer = ANTLRv4Lexer(input_stream)
    stream = CommonTokenStream(lexer)
    parser = ANTLRv4Parser(stream)

    # Start parsing at the 'grammarSpec' rule
    tree = parser.grammarSpec()

    # Create a visitor and evaluate the expression
    converter = ANTLR2FanVisitor()
    result = converter.visit(tree)
    print(result, end="")

if __name__ == "__main__":
    for filename in sys.argv[1:]:
        process(filename)