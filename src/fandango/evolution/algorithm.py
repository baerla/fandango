# evolution/algorithm.py
import random
import time
from typing import List, Set, Tuple

from build.lib.fandango.language.grammar import DerivationTree
from fandango.constraints.base import Constraint
from fandango.constraints.fitness import FailingTree
from fandango.language.grammar import (
    Grammar,
)
from fandango.language.parse import parse_file


class FANDANGO:
    def __init__(
            self,
            grammar: Grammar,
            constraints: List[Constraint],
            population_size: int = 100,
            max_generations: int = 1000,
            elitism_rate: float = 0.1,
            crossover_rate: float = 0.8,
            tournament_size: float = 0.05,
            mutation_rate: float = 0.2,
            verbose: bool = False,
    ):
        """
        Initialize the FANDANGO genetic algorithm. The algorithm will evolve a population of individuals
        that are generated by the given grammar, and will evaluate them against the given constraints.

        :param grammar: The grammar used to generate individuals.
        :param constraints: The constraints used to evaluate individuals.
        :param population_size: The size of the population.
        :param max_generations: The maximum number of generations to run the algorithm.
        :param elitism_rate: The rate of individuals that will be preserved in the next generation.
        :param crossover_rate: The rate of individuals that will undergo crossover.
        :param mutation_rate: The rate of individuals that will undergo mutation.
        :param verbose: Whether to print information about the evolution process.
        """
        self.grammar = grammar
        self.constraints = constraints
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.tournament_size = int(population_size * tournament_size)
        self.max_generations = max_generations
        self.elitism_rate = elitism_rate

        self.verbose = verbose
        self.checks_made = 0
        self.crossovers_made = 0
        self.mutations_made = 0

        self.time_taken = None

        # Initialize population
        self.population = self.generate_random_initial_population()

        # Evaluate population
        self.fitness_cache = {}
        self.evaluation = self.evaluate_population()
        self.fitness = sum(fitness for _, fitness, _ in self.evaluation) / len(self.evaluation)

        self.solution = set()

    def evolve(self) -> Set[DerivationTree]:
        """
        Run the genetic algorithm to evolve the population over multiple generations.

        :return: The best solution found by the algorithm.
        """
        start_time = time.time()

        for generation in range(1, self.max_generations + 1):
            if self.verbose:
                print(f"[DEBUG] - Generation {generation} - Fitness: {self.fitness:.2f}")

            if self.fitness >= 0.95 or len(self.solution) >= self.population_size:
                break

            # Select elites
            population = self.select_elites()

            if self.verbose:
                print(f"[DEBUG] - Elites: {population}")

            # Crossover
            while len(population) < self.population_size:
                pass

        self.time_taken = time.time() - start_time
        self.solution = self.population
        print(f"[INFO] - Solution not found after {self.max_generations} generations.")
        print(f"[INFO] - Best solution: {self.solution}")

        if self.verbose:
            print(f"[DEBUG] - Fitness: {self.fitness}")
            print(f"[DEBUG] - Fitness checks: {self.checks_made}")
            print(f"[DEBUG] - Crossovers made: {self.crossovers_made}")
            print(f"[DEBUG] - Mutations made: {self.mutations_made}")
            print(f"[DEBUG] - Time taken: {self.time_taken:.2f} seconds")

        return self.population

    def generate_random_initial_population(self) -> Set[DerivationTree]:
        """
        Generate the initial population of individuals.

        :return: A set of individuals.
        """

        population = set()
        str_repr = set()
        while len(population) < self.population_size:
            individual = self.grammar.fuzz()
            if str(individual) not in str_repr:
                population.add(individual)
                str_repr.add(str(individual))
        return population

    def generate_coverage_based_initial_population(self) -> Set[DerivationTree]:
        """
        Generate the initial population of individuals that maximize the coverage of the grammar.

        :return: A set of individuals.
        """
        pass

    def evaluate_individual(self, individual: DerivationTree) -> Tuple[float, List[FailingTree]]:
        """
        Evaluate the fitness of an individual.

        :param individual: The individual to evaluate.
        :return: The fitness of the individual and the list of failing trees.
        """
        fitness = 0.0
        failing_trees = []

        if str(individual) in self.fitness_cache:
            return self.fitness_cache[str(individual)]

        for constraint in self.constraints:
            result = constraint.fitness(individual)
            if result.success:
                fitness += result.fitness()
            else:
                failing_trees.extend(result.failing_trees)
                fitness += result.fitness()

            self.checks_made += 1
            self.fitness_cache[str(individual)] = [fitness, failing_trees]

        fitness /= len(self.constraints)
        return fitness, failing_trees

    def evaluate_population(self) -> List[Tuple[DerivationTree, float, List[FailingTree]]]:
        """
        Evaluate the fitness of each individual in the population.

        :return: A list of tuples, each containing an individual, its fitness, and the list of failing trees.
        """
        evaluation = [(individual, *self.evaluate_individual(individual)) for individual in self.population]
        self.fitness = sum(fitness for _, fitness, _ in evaluation) / len(evaluation)
        return evaluation

    def select_elites(self) -> List[DerivationTree]:
        """
        Select the 'elitism'% elite individuals from the population based on the fitness.

        :return: A list of elite individuals.
        """
        return [x[0] for x in sorted(self.evaluation, key=lambda x: x[1], reverse=True)[
                              :int(self.elitism_rate * self.population_size)]]

    def tournament_selection(self) -> Tuple[DerivationTree, DerivationTree]:
        """
        Perform tournament selection to choose two parents for crossover.
        """
        tournament = random.sample(self.population, self.tournament_size)
        tournament.sort(key=lambda x: x['fitness'], reverse=True)
        return tournament[0], tournament[1]


if __name__ == "__main__":
    grammar_, constraints_ = parse_file("../../evaluation/experiments/int/int.fan")

    fandango = FANDANGO(grammar_, constraints_, verbose=True)
    fandango.evolve()
