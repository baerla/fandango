# evolution/algorithm.py
import random
import time
from typing import List, Set, Tuple

from build.lib.fandango.language.grammar import DerivationTree
from fandango.constraints.base import Constraint
from fandango.constraints.fitness import FailingTree
from fandango.language.grammar import (
    Grammar,
)
from fandango.language.parse import parse_file


class FANDANGO:
    def __init__(
            self,
            grammar: Grammar,
            constraints: List[Constraint],
            population_size: int = 100,
            max_generations: int = 1000,
            elitism_rate: float = 0.1,
            crossover_rate: float = 0.8,
            tournament_size: float = 0.05,
            mutation_rate: float = 0.2,
            verbose: bool = False,
    ):
        """
        Initialize the FANDANGO genetic algorithm. The algorithm will evolve a population of individuals
        that are generated by the given grammar, and will evaluate them against the given constraints.

        :param grammar: The grammar used to generate individuals.
        :param constraints: The constraints used to evaluate individuals.
        :param population_size: The size of the population.
        :param max_generations: The maximum number of generations to run the algorithm.
        :param elitism_rate: The rate of individuals that will be preserved in the next generation.
        :param crossover_rate: The rate of individuals that will undergo crossover.
        :param mutation_rate: The rate of individuals that will undergo mutation.
        :param verbose: Whether to print information about the evolution process.
        """
        self.grammar = grammar
        self.constraints = constraints
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.tournament_size = int(population_size * tournament_size)
        self.max_generations = max_generations
        self.elitism_rate = elitism_rate

        self.verbose = verbose
        self.checks_made = 0
        self.crossovers_made = 0
        self.mutations_made = 0

        self.time_taken = None

        # Initialize population
        self.solution = set()
        self.population = self.generate_random_initial_population()

        # Evaluate population
        self.fitness_cache = {}
        self.evaluation = self.evaluate_population()
        self.fitness = sum(fitness for _, fitness, _ in self.evaluation) / self.population_size

    def evolve(self) -> Set[DerivationTree]:
        """
        Run the genetic algorithm to evolve the population over multiple generations.

        :return: The best solution found by the algorithm.
        """
        start_time = time.time()

        for generation in range(1, self.max_generations + 1):
            if self.verbose:
                print(f"[DEBUG] - Generation {generation} - Fitness: {self.fitness:.2f}")

            if len(self.solution) >= self.population_size:
                break

            if self.verbose:
                print(f"[DEBUG] - Population: {self.population}")

            # Select elites
            population = self.select_elites()

            if self.verbose:
                print(f"[DEBUG] - Elites: {population}")

            # # Crossover
            # while len(population) < self.population_size:
            #     break

            # Mutation
            for individual in population:
                if random.random() < self.mutation_rate:
                    population.remove(individual)
                    population.append(self.mutate(individual))
                    self.mutations_made += 1

            # Remove duplicates
            population = set(population)

            # Add new individuals
            while len(population) < self.population_size:
                population.add(self.grammar.fuzz())

            # Evaluate population
            self.population = population
            self.evaluation = self.evaluate_population()
            self.fitness = sum(fitness for _, fitness, _ in self.evaluation) / self.population_size
            cosa = [fitness for _, fitness, _ in self.evaluation]

        self.time_taken = time.time() - start_time
        print(f"[INFO] - Best solution: {self.solution}")

        if self.verbose:
            print(f"[DEBUG] - Fitness: {self.fitness}")
            print(f"[DEBUG] - Fitness checks: {self.checks_made}")
            print(f"[DEBUG] - Crossovers made: {self.crossovers_made}")
            print(f"[DEBUG] - Mutations made: {self.mutations_made}")
            print(f"[DEBUG] - Time taken: {self.time_taken:.2f} seconds")

        return self.population

    def generate_random_initial_population(self) -> Set[DerivationTree]:
        """
        Generate the initial population of individuals.

        :return: A set of individuals.
        """

        population = set()
        str_repr = set()
        while len(population) < self.population_size:
            individual = self.grammar.fuzz()
            if str(individual) not in str_repr:
                population.add(individual)
                str_repr.add(str(individual))
        return population

    def generate_coverage_based_initial_population(self) -> Set[DerivationTree]:
        """
        Generate the initial population of individuals that maximize the coverage of the grammar.

        :return: A set of individuals.
        """
        pass

    def evaluate_individual(self, individual: DerivationTree) -> Tuple[float, List[FailingTree]]:
        """
        Evaluate the fitness of an individual.

        :param individual: The individual to evaluate.
        :return: The fitness of the individual and the list of failing trees.
        """
        fitness = 0.0
        failing_trees = []

        if str(individual) in self.fitness_cache:
            return self.fitness_cache[str(individual)]

        for constraint in self.constraints:
            result = constraint.fitness(individual)
            if result.success:
                fitness += result.fitness()
            else:
                failing_trees.extend(result.failing_trees)
                fitness += result.fitness()
            self.checks_made += 1

        # Normalize fitness
        fitness = fitness / len(self.constraints)
        if fitness >= 0.99:
            self.solution.add(individual)

        self.fitness_cache[str(individual)] = [fitness, failing_trees]
        return fitness, failing_trees

    def evaluate_population(self) -> List[Tuple[DerivationTree, float, List[FailingTree]]]:
        """
        Evaluate the fitness of each individual in the population.

        :return: A list of tuples, each containing an individual, its fitness, and the list of failing trees.
        """
        evaluation = []
        for individual in self.population:
            fitness, failing_trees = self.evaluate_individual(individual)
            if fitness > 1.0:
                print(f"[WARNING] - Fitness of individual {individual} is greater than 1.0: {fitness}")
            evaluation.append((individual, fitness, failing_trees))
        print(evaluation)
        return evaluation

    def select_elites(self) -> List[DerivationTree]:
        """
        Select the 'elitism'% elite individuals from the population based on the fitness.

        :return: A list of elite individuals.
        """
        return [x[0] for x in sorted(self.evaluation, key=lambda x: x[1], reverse=True)[
                              :int(self.elitism_rate * self.population_size)]]

    def tournament_selection(self) -> Tuple[DerivationTree, DerivationTree]:
        """
        Perform tournament selection to choose two parents for crossover.
        """
        tournament = random.sample(self.population, self.tournament_size)
        tournament.sort(key=lambda x: x['fitness'], reverse=True)
        return tournament[0], tournament[1]

    def crossover(self, parent1: DerivationTree, parent2: DerivationTree) -> [DerivationTree, DerivationTree]:
        """
        Perform crossover between two parents to generate two children based on the failing trees.
        """
        pass

    def mutate(self, individual: DerivationTree) -> DerivationTree:
        """
        Perform mutation on an individual to generate a new individual based on the failing trees.
        """
        failing_trees = self.evaluate_individual(individual)[1]
        selection = []

        for failing_tree in failing_trees:
            selection.append(failing_tree.tree)

        if len(selection) == 0:
            return individual
        else:
            node_to_mutate = random.choice(selection)
            if node_to_mutate.symbol.is_non_terminal:
                new_subtree = self.grammar.fuzz(node_to_mutate.symbol)
                individual = individual.replace(node_to_mutate, new_subtree)
                self.mutations_made += 1
        return individual


if __name__ == "__main__":
    grammar_, constraints_ = parse_file("../../evaluation/experiments/int/int.fan")

    fandango = FANDANGO(grammar_, constraints_, verbose=True)
    fandango.evolve()
