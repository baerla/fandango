# evolution/algorithm.py
import copy
import random
import time
from typing import List, Set, Tuple

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics import jaccard_score

from fandango.constraints.base import Constraint
from fandango.constraints.fitness import FailingTree, Comparison, ComparisonSide
from fandango.language.grammar import DerivationTree
from fandango.language.grammar import (
    Grammar,
)
from fandango.language.parse import parse_file


class FANDANGO:
    def __init__(
            self,
            grammar: Grammar,
            constraints: List[Constraint],
            population_size: int = 100,
            desired_solutions: int = 0,
            initial_population: List[DerivationTree] = None,
            max_generations: int = 500,
            elitism_rate: float = 0.1,
            crossover_rate: float = 0.8,
            tournament_size: float = 0.1,
            mutation_rate: float = 0.2,
            verbose: bool = False,
    ):
        """
        Initialize the FANDANGO genetic algorithm. The algorithm will evolve a population of individuals
        that are generated by the given grammar, and will evaluate them against the given constraints.

        :param grammar: The grammar used to generate individuals.
        :param constraints: The constraints used to evaluate individuals.
        :param population_size: The size of the population.
        :param max_generations: The maximum number of generations to run the algorithm.
        :param elitism_rate: The rate of individuals that will be preserved in the next generation.
        :param crossover_rate: The rate of individuals that will undergo crossover.
        :param mutation_rate: The rate of individuals that will undergo mutation.
        :param verbose: Whether to print information about the evolution process.
        """
        print(f" ---------- Initializing FANDANGO algorithm ---------- ")
        self.grammar = grammar
        self.constraints = constraints
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.tournament_size = int(population_size * tournament_size) or population_size
        self.max_generations = max_generations
        self.elitism_rate = elitism_rate

        self.fitness_cache = {}

        self.verbose = verbose
        self.fixes_made = 0
        self.checks_made = 0
        self.crossovers_made = 0
        self.mutations_made = 0

        self.time_taken = None

        # Initialize population
        self.solution = list()

        self.desired_solutions = desired_solutions

        if initial_population is not None:
            self.population = list(initial_population)
        else:
            print("[INFO] - Generating initial population...")
            st_time = time.time()
            self.population = self.generate_random_initial_population()
            print(
                f"[INFO] - Initial population generated in {time.time() - st_time:.2f} seconds"
            )

        # Evaluate population
        self.evaluation = self.evaluate_population()
        self.fitness = (
                sum(fitness for _, fitness, _ in self.evaluation) / self.population_size
        )
        print(f" ---------- Starting evolution ---------- ")

    def evolve(self) -> List[DerivationTree]:
        """
        Run the genetic algorithm to evolve the population over multiple generations.

        :return: The best solution found by the algorithm.
        """
        start_time = time.time()

        for generation in range(1, self.max_generations + 1):
            if 0 < self.desired_solutions <= len(self.solution):
                self.fitness = 1.0
                self.solution = self.solution[:self.desired_solutions]
                break
            elif self.desired_solutions == 0:
                if self.fitness >= 0.99:
                    self.fitness = 1.0
                    self.solution = self.population[:self.population_size]
                    break
                if len(self.solution) >= self.population_size:
                    self.fitness = 1.0
                    self.solution = self.solution[:self.population_size]

            print(
                f"[INFO] - Generation {generation} - Fitness: {self.fitness:.2f} - "
                f"#solutions found: {len(self.solution)}"
            )

            # Select elites
            new_population = self.select_elites()

            # Crossover
            while len(new_population) < self.population_size:
                if random.random() < self.crossover_rate:
                    parent1, parent2 = self.tournament_selection()
                    child1, child2 = self.crossover(parent1, parent2)
                    new_population.append(child1)
                    new_population.append(child2)
                    self.crossovers_made += 1

            new_population = new_population[: self.population_size]

            # Mutation
            for individual in new_population:
                if random.random() < self.mutation_rate:
                    new_population.remove(individual)
                    new_population.append(self.mutate(individual))
                    self.mutations_made += 1

            # Add new individuals
            while len(new_population) < self.population_size:
                new_population.append(self.grammar.fuzz())

            # Fix individuals
            fixed_population = list()
            for individual in new_population:
                fixed_population.append(self.fix_individual(individual))

            # Evaluate population
            self.population = fixed_population[: self.population_size]
            self.evaluation = self.evaluate_population()
            self.fitness = (
                    sum(fitness for _, fitness, _ in self.evaluation) / self.population_size
            )

        self.time_taken = time.time() - start_time

        print(f" ---------- Evolution finished ---------- ")
        print(
            f"[INFO] - Perfect solutions found: ({len(self.solution)}) "
            f"- Fitness of final population: {self.fitness:.2f}"
        )
        print(f"[INFO] - Time taken: {self.time_taken:.2f} seconds")

        if self.verbose:
            print(f" ---------- FANDANGO statistics ---------- ")
            print(f"[DEBUG] - Diversity score: {self.compute_diversity_score():.2f}")
            print(f"[DEBUG] - Fixes made: {self.fixes_made}")
            print(f"[DEBUG] - Fitness checks: {self.checks_made}")
            print(f"[DEBUG] - Crossovers made: {self.crossovers_made}")
            print(f"[DEBUG] - Mutations made: {self.mutations_made}")

        return self.population

    def generate_random_initial_population(self) -> List[DerivationTree]:
        """
        Generate the initial population of individuals.

        :return: A set of individuals.
        """

        population = [self.grammar.fuzz() for _ in range(self.population_size)]

        # Fix individuals
        fixed_population = list()
        for individual in population:
            fixed_population.append(self.fix_individual(individual))

        return fixed_population

    def generate_coverage_based_initial_population(self) -> Set[DerivationTree]:
        """
        Generate the initial population of individuals that maximize the coverage of the grammar.

        :return: A set of individuals.
        """
        pass

    def fix_individual(self, individual: DerivationTree) -> DerivationTree:
        """
        Fix an individual by replacing failing subtrees if ComparisonConstraint.EQUAL are involved.
        """

        evaluation = self.evaluate_individual(individual)
        failing_trees = evaluation[1]
        for failing_tree in failing_trees:
            for operator, value, side in failing_tree.suggestions:
                if operator == Comparison.EQUAL and side == ComparisonSide.LEFT:
                    suggested_tree = self.grammar.parse(
                        str(value), failing_tree.tree.symbol
                    )
                    if suggested_tree is None:
                        continue
                    individual = individual.replace(failing_tree.tree, suggested_tree)
                    self.fixes_made += 1
        return individual

    def evaluate_individual(
            self, individual: DerivationTree
    ) -> Tuple[float, List[FailingTree]]:
        """
        Evaluate the fitness of an individual.

        :param individual: The individual to evaluate.
        :return: The fitness of the individual and the list of failing trees.
        """
        fitness = 0.0
        failing_trees = []

        if str(individual) in self.fitness_cache:
            return self.fitness_cache[str(individual)]

        for constraint in self.constraints:
            result = constraint.fitness(individual)
            if result.success:
                fitness += result.fitness()
            else:
                failing_trees.extend(result.failing_trees)
                fitness += result.fitness()
            self.checks_made += 1

        # Normalize fitness
        try:
            fitness /= len(self.constraints)
        except ZeroDivisionError:
            fitness = 1.0

        if fitness >= 0.99:
            self.solution.append(individual)

        self.fitness_cache[str(individual)] = [fitness, failing_trees]
        return fitness, failing_trees

    def evaluate_population(
            self,
    ) -> List[Tuple[DerivationTree, float, List[FailingTree]]]:
        """
        Evaluate the fitness of each individual in the population.

        :return: A list of tuples, each containing an individual, its fitness, and the list of failing trees.
        """
        evaluation = []
        for individual in self.population:
            fitness, failing_trees = self.evaluate_individual(individual)
            evaluation.append((individual, fitness, failing_trees))
        return evaluation

    def select_elites(self) -> List[DerivationTree]:
        """
        Select the 'elitism'% elite individuals from the population based on the fitness.

        :return: A list of elite individuals.
        """
        return [
            x[0]
            for x in sorted(self.evaluation, key=lambda x: x[1], reverse=True)[
                     : int(self.elitism_rate * self.population_size)
                     ]
        ]

    def tournament_selection(self) -> Tuple[DerivationTree, DerivationTree]:
        """
        Perform tournament selection to choose two parents for crossover.
        """
        tournament = random.sample(self.evaluation, k=self.tournament_size)
        tournament.sort(key=lambda x: x[1], reverse=True)
        parent1 = tournament[0][0]
        parent2 = tournament[1][0]
        return parent1, parent2

    # noinspection PyMethodMayBeStatic
    def crossover(
            self, parent1: DerivationTree, parent2: DerivationTree
    ) -> Tuple[DerivationTree, DerivationTree]:
        """
        Perform crossover between two parents to generate two children by swapping subtrees rooted at a common
        non-terminal symbol.
        """
        # Get all non-terminal symbols in parent1 and parent2
        symbols1 = parent1.get_non_terminal_symbols()
        symbols2 = parent2.get_non_terminal_symbols()

        # Find common non-terminal symbols
        common_symbols = symbols1.intersection(symbols2)

        if not common_symbols:
            return parent1, parent2

        # Randomly select a common non-terminal symbol
        symbol = random.choice(list(common_symbols))

        # Find all nodes with that symbol in parent1 and parent2
        nodes1 = parent1.find_all_nodes(symbol)
        nodes2 = parent2.find_all_nodes(symbol)

        # Randomly select one node from each parent
        node1 = random.choice(nodes1)
        node2 = random.choice(nodes2)

        # Swap subtrees
        child1 = parent1.replace(node1, copy.deepcopy(node2))
        child2 = parent2.replace(node2, copy.deepcopy(node1))

        return child1, child2

    def mutate(self, individual: DerivationTree) -> DerivationTree:
        """
        Perform mutation on an individual to generate a new individual based on the failing trees.
        """
        failing_trees = self.evaluate_individual(individual)[1]
        selection = []

        for failing_tree in failing_trees:
            selection.append(failing_tree.tree)

        if len(selection) == 0:
            return individual
        else:
            node_to_mutate = random.choice(selection)
            if node_to_mutate.symbol.is_non_terminal:
                new_subtree = self.grammar.fuzz(node_to_mutate.symbol)
                individual = individual.replace(node_to_mutate, new_subtree)
                self.mutations_made += 1
        return individual

    def compute_diversity_score(self, ngram_range=(2, 2)):
        """
        Compute the diversity score of a list of strings based on pairwise Jaccard distance.

        Args:
        - str_list: List of strings to evaluate.
        - ngram_range: The n-gram range for tokenization (default is bigrams).

        Returns:
        - diversity_score: A number between 0 and 1 representing the overall diversity.
        """
        population = [str(x) for x in self.population]

        # Step 1: Convert strings into n-gram sets using CountVectorizer
        vectorizer = CountVectorizer(analyzer='char', ngram_range=ngram_range, binary=True)
        ngram_matrix = vectorizer.fit_transform(population).toarray()

        # Step 2: Compute pairwise Jaccard distances
        num_strings = len(population)
        total_distance = 0
        num_pairs = 0

        # Iterate over all pairs of strings to compute average dissimilarity
        for i in range(num_strings):
            for j in range(i + 1, num_strings):
                # Compute Jaccard similarity
                sim = jaccard_score(ngram_matrix[i], ngram_matrix[j])
                # Convert to Jaccard distance
                distance = 1 - sim
                total_distance += distance
                num_pairs += 1

        # Step 3: Compute the average Jaccard distance (dissimilarity)
        if num_pairs == 0:
            return 0  # Only one string, no diversity

        avg_dissimilarity = total_distance / num_pairs

        # Return diversity score (between 0 and 1)
        return avg_dissimilarity


if __name__ == "__main__":
    grammar_, constraints_ = parse_file("../../evaluation/demo/demo.fan")

    fandango = FANDANGO(grammar_, constraints_, verbose=False)
    fandango.evolve()
